package rule

import (
	"encoding/json/v2"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"time"

	"github.com/sony/sonyflake"
	"github.com/xeipuuv/gojsonschema"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"

	v1 "github.com/tianping526/eventbridge/apis/api/eventbridge/service/v1"
)

var sourceIDGenMapping sync.Map

type EventExt struct {
	*v1.EventExt
}

// NewEventExt when the ID of an event is zero, it is reassigned a unique ID under a source
func NewEventExt(evt *v1.Event, retry v1.RetryStrategy) (*EventExt, error) {
	if evt.Id == 0 {
		val, ok := sourceIDGenMapping.Load(evt.Source)
		var idGen *sonyflake.Sonyflake
		if ok {
			idGen = val.(*sonyflake.Sonyflake)
		} else {
			st, _ := time.Parse("2006-01-02", "2022-08-10")
			idGen = sonyflake.NewSonyflake(
				sonyflake.Settings{
					StartTime: st,
				},
			)
			sourceIDGenMapping.Store(evt.Source, idGen)
		}

		id, err := idGen.NextID()
		if err != nil {
			return nil, err
		}
		evt.Id = id
	}

	return &EventExt{
		EventExt: &v1.EventExt{
			Event:         evt,
			RetryStrategy: retry,
		},
	}, nil
}

func NewEventExtFromBytes(b []byte) (*EventExt, error) {
	cee := &v1.EventExt{}
	err := proto.Unmarshal(b, cee)
	if err != nil {
		return nil, err
	}
	return &EventExt{
		EventExt: cee,
	}, nil
}

func CloneEventExt(evt *EventExt) *EventExt {
	var subject *string
	if evt.Event.Subject != nil {
		subjectCopy := *evt.Event.Subject
		subject = &subjectCopy
	}
	var eTime *timestamppb.Timestamp
	if evt.Event.Time != nil {
		eTime = &timestamppb.Timestamp{
			Seconds: evt.Event.Time.Seconds,
			Nanos:   evt.Event.Time.Nanos,
		}
	}
	meta := make(map[string]string)
	for k, v := range evt.Metadata {
		meta[k] = v
	}
	return &EventExt{
		EventExt: &v1.EventExt{
			Event: &v1.Event{
				Id:              evt.Event.Id,
				Source:          evt.Event.Source,
				Subject:         subject,
				Type:            evt.Event.Type,
				Time:            eTime,
				Data:            evt.Event.Data,
				Datacontenttype: evt.Event.Datacontenttype,
			},
			BusName:       evt.BusName,
			RuleName:      evt.RuleName,
			TargetId:      evt.TargetId,
			RetryStrategy: evt.RetryStrategy,
			Metadata:      meta,
		},
	}
}

func (e *EventExt) Key() string {
	if e.RuleName != "" {
		return fmt.Sprintf(
			"%s%s%d%s%d", e.Event.Source, e.Event.Type, e.Event.Id, e.RuleName, e.TargetId,
		)
	}
	return fmt.Sprintf("%s%s%d", e.Event.Source, e.Event.Type, e.Event.Id)
}

func (e *EventExt) Value() []byte {
	bs, _ := proto.Marshal(e.EventExt)
	return bs
}

// ValidateEventData checking data field by schema definition
func (e *EventExt) ValidateEventData(validator *gojsonschema.Schema) error {
	result, err := validator.Validate(gojsonschema.NewStringLoader(e.Event.Data))
	if err != nil {
		return fmt.Errorf(
			"event data validation error: %w", err,
		)
	}
	if !result.Valid() {
		return v1.ErrorEventDataNotValid(
			"event data is not valid. see err: %s", result.Errors(),
		)
	}
	return nil
}

type NotExistsValT struct{}

var notExistsVal = &NotExistsValT{}

// IsNotExistsVal determine if a value is a non-existent value, i.e., a value generated by NewNotExistsVal
func IsNotExistsVal(val interface{}) bool {
	return notExistsVal == val
}

// NewNotExistsVal generate a value to represent a value that does not exist
func NewNotExistsVal() *NotExistsValT {
	return notExistsVal
}

// GetFieldByPath get internal field value by path.
// e.g.: ["data", "source"] -> e.Event.Data.source.
// if the path does not exist,
// the function will return the value generated by NewNotExistsVal to distinguish nil.
// if the event data is parsed incorrectly,
// the function will return a *dataUnmarshalError error,
// which can be asserted using the function IsDataUnmarshalError.
// all numbers use float64.
// to prevent precision overflow, id returns a string type.
func (e *EventExt) GetFieldByPath(path []string) (interface{}, error) {
	if len(path) == 0 {
		return e.Event, nil
	}

	if len(path) == 1 {
		switch path[0] {
		case "id":
			return strconv.FormatUint(e.Event.Id, 10), nil
		case "source":
			return e.Event.Source, nil
		case "subject":
			if e.Event.Subject == nil {
				return e.Event.Subject, nil
			}
			return *e.Event.Subject, nil
		case "type":
			return e.Event.Type, nil
		case "time":
			return e.Event.Time.AsTime(), nil
		case "data":
			var data interface{}
			err := json.Unmarshal([]byte(e.Event.Data), &data)
			if err != nil {
				return nil, newDataUnmarshalError(err)
			}
			return data, nil
		case "datacontenttype":
			return e.Event.Datacontenttype, nil
		default:
			return NewNotExistsVal(), nil
		}
	}

	if path[0] != "data" {
		return NewNotExistsVal(), nil
	}

	var data interface{}
	err := json.Unmarshal([]byte(e.Event.Data), &data)
	if err != nil {
		return nil, newDataUnmarshalError(err)
	}

	for _, key := range path[1:] {
		switch dataVal := data.(type) {
		case map[string]interface{}:
			var ok bool
			data, ok = dataVal[key]
			if !ok {
				return NewNotExistsVal(), nil
			}
		case []interface{}:
			idx, errPi := strconv.ParseInt(key, 10, 64)
			if errPi != nil {
				return NewNotExistsVal(), nil
			}
			if idx >= int64(len(dataVal)) {
				return NewNotExistsVal(), nil
			}
			data = dataVal[idx]
		default:
			return NewNotExistsVal(), nil
		}
	}
	return data, nil
}

func newDataUnmarshalError(err error) *dataUnmarshalError {
	return &dataUnmarshalError{
		error: fmt.Errorf("event data unmarshal err: %w", err),
	}
}

type dataUnmarshalError struct {
	error
}

func (due *dataUnmarshalError) Error() string {
	return due.error.Error()
}

func (due *dataUnmarshalError) Is(err error) bool {
	var target *dataUnmarshalError
	ok := errors.As(err, &target)
	return ok
}

func IsDataUnmarshalError(err error) bool {
	return errors.Is(err, &dataUnmarshalError{})
}
